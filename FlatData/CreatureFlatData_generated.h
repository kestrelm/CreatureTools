// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CREATUREFLATDATA_CREATUREFLATDATA_H_
#define FLATBUFFERS_GENERATED_CREATUREFLATDATA_CREATUREFLATDATA_H_

#include "flatbuffers.h"


namespace CreatureFlatData {

struct meshRegionBone;
struct meshRegion;
struct mesh;
struct skeletonBone;
struct skeleton;
struct animationBone;
struct animationBonesTimeSample;
struct animationBonesList;
struct animationMesh;
struct animationMeshTimeSample;
struct animationMeshList;
struct animationUVSwap;
struct animationUVSwapTimeSample;
struct animationUVSwapList;
struct animationMeshOpacity;
struct animationMeshOpacityTimeSample;
struct animationMeshOpacityList;
struct animationClip;
struct animation;
struct rootData;

struct meshRegionBone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::Vector<float> *weights() const { return GetPointer<const flatbuffers::Vector<float> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* weights */) &&
           verifier.Verify(weights()) &&
           verifier.EndTable();
  }
};

struct meshRegionBoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_weights(flatbuffers::Offset<flatbuffers::Vector<float>> weights) { fbb_.AddOffset(6, weights); }
  meshRegionBoneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  meshRegionBoneBuilder &operator=(const meshRegionBoneBuilder &);
  flatbuffers::Offset<meshRegionBone> Finish() {
    auto o = flatbuffers::Offset<meshRegionBone>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<meshRegionBone> CreatemeshRegionBone(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> weights = 0) {
  meshRegionBoneBuilder builder_(_fbb);
  builder_.add_weights(weights);
  builder_.add_name(name);
  return builder_.Finish();
}

struct meshRegion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t start_pt_index() const { return GetField<int32_t>(6, 0); }
  int32_t end_pt_index() const { return GetField<int32_t>(8, 0); }
  int32_t start_index() const { return GetField<int32_t>(10, 0); }
  int32_t end_index() const { return GetField<int32_t>(12, 0); }
  int32_t id() const { return GetField<int32_t>(14, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<meshRegionBone>> *weights() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<meshRegionBone>> *>(16); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* start_pt_index */) &&
           VerifyField<int32_t>(verifier, 8 /* end_pt_index */) &&
           VerifyField<int32_t>(verifier, 10 /* start_index */) &&
           VerifyField<int32_t>(verifier, 12 /* end_index */) &&
           VerifyField<int32_t>(verifier, 14 /* id */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* weights */) &&
           verifier.Verify(weights()) &&
           verifier.VerifyVectorOfTables(weights()) &&
           verifier.EndTable();
  }
};

struct meshRegionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_start_pt_index(int32_t start_pt_index) { fbb_.AddElement<int32_t>(6, start_pt_index, 0); }
  void add_end_pt_index(int32_t end_pt_index) { fbb_.AddElement<int32_t>(8, end_pt_index, 0); }
  void add_start_index(int32_t start_index) { fbb_.AddElement<int32_t>(10, start_index, 0); }
  void add_end_index(int32_t end_index) { fbb_.AddElement<int32_t>(12, end_index, 0); }
  void add_id(int32_t id) { fbb_.AddElement<int32_t>(14, id, 0); }
  void add_weights(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshRegionBone>>> weights) { fbb_.AddOffset(16, weights); }
  meshRegionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  meshRegionBuilder &operator=(const meshRegionBuilder &);
  flatbuffers::Offset<meshRegion> Finish() {
    auto o = flatbuffers::Offset<meshRegion>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<meshRegion> CreatemeshRegion(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t start_pt_index = 0,
   int32_t end_pt_index = 0,
   int32_t start_index = 0,
   int32_t end_index = 0,
   int32_t id = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshRegionBone>>> weights = 0) {
  meshRegionBuilder builder_(_fbb);
  builder_.add_weights(weights);
  builder_.add_id(id);
  builder_.add_end_index(end_index);
  builder_.add_start_index(start_index);
  builder_.add_end_pt_index(end_pt_index);
  builder_.add_start_pt_index(start_pt_index);
  builder_.add_name(name);
  return builder_.Finish();
}

struct mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<float> *points() const { return GetPointer<const flatbuffers::Vector<float> *>(4); }
  const flatbuffers::Vector<float> *uvs() const { return GetPointer<const flatbuffers::Vector<float> *>(6); }
  const flatbuffers::Vector<int32_t> *indices() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(8); }
  const flatbuffers::Vector<flatbuffers::Offset<meshRegion>> *regions() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<meshRegion>> *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* points */) &&
           verifier.Verify(points()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* uvs */) &&
           verifier.Verify(uvs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* indices */) &&
           verifier.Verify(indices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* regions */) &&
           verifier.Verify(regions()) &&
           verifier.VerifyVectorOfTables(regions()) &&
           verifier.EndTable();
  }
};

struct meshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<float>> points) { fbb_.AddOffset(4, points); }
  void add_uvs(flatbuffers::Offset<flatbuffers::Vector<float>> uvs) { fbb_.AddOffset(6, uvs); }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices) { fbb_.AddOffset(8, indices); }
  void add_regions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshRegion>>> regions) { fbb_.AddOffset(10, regions); }
  meshBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  meshBuilder &operator=(const meshBuilder &);
  flatbuffers::Offset<mesh> Finish() {
    auto o = flatbuffers::Offset<mesh>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<mesh> Createmesh(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<float>> points = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> uvs = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshRegion>>> regions = 0) {
  meshBuilder builder_(_fbb);
  builder_.add_regions(regions);
  builder_.add_indices(indices);
  builder_.add_uvs(uvs);
  builder_.add_points(points);
  return builder_.Finish();
}

struct skeletonBone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t id() const { return GetField<int32_t>(6, 0); }
  const flatbuffers::Vector<float> *restParentMat() const { return GetPointer<const flatbuffers::Vector<float> *>(8); }
  const flatbuffers::Vector<float> *localRestStartPt() const { return GetPointer<const flatbuffers::Vector<float> *>(10); }
  const flatbuffers::Vector<float> *localRestEndPt() const { return GetPointer<const flatbuffers::Vector<float> *>(12); }
  const flatbuffers::Vector<int32_t> *children() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* id */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* restParentMat */) &&
           verifier.Verify(restParentMat()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* localRestStartPt */) &&
           verifier.Verify(localRestStartPt()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* localRestEndPt */) &&
           verifier.Verify(localRestEndPt()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* children */) &&
           verifier.Verify(children()) &&
           verifier.EndTable();
  }
};

struct skeletonBoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_id(int32_t id) { fbb_.AddElement<int32_t>(6, id, 0); }
  void add_restParentMat(flatbuffers::Offset<flatbuffers::Vector<float>> restParentMat) { fbb_.AddOffset(8, restParentMat); }
  void add_localRestStartPt(flatbuffers::Offset<flatbuffers::Vector<float>> localRestStartPt) { fbb_.AddOffset(10, localRestStartPt); }
  void add_localRestEndPt(flatbuffers::Offset<flatbuffers::Vector<float>> localRestEndPt) { fbb_.AddOffset(12, localRestEndPt); }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<int32_t>> children) { fbb_.AddOffset(14, children); }
  skeletonBoneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  skeletonBoneBuilder &operator=(const skeletonBoneBuilder &);
  flatbuffers::Offset<skeletonBone> Finish() {
    auto o = flatbuffers::Offset<skeletonBone>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<skeletonBone> CreateskeletonBone(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t id = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> restParentMat = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> localRestStartPt = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> localRestEndPt = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> children = 0) {
  skeletonBoneBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_localRestEndPt(localRestEndPt);
  builder_.add_localRestStartPt(localRestStartPt);
  builder_.add_restParentMat(restParentMat);
  builder_.add_id(id);
  builder_.add_name(name);
  return builder_.Finish();
}

struct skeleton FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<skeletonBone>> *bones() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<skeletonBone>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* bones */) &&
           verifier.Verify(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           verifier.EndTable();
  }
};

struct skeletonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<skeletonBone>>> bones) { fbb_.AddOffset(4, bones); }
  skeletonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  skeletonBuilder &operator=(const skeletonBuilder &);
  flatbuffers::Offset<skeleton> Finish() {
    auto o = flatbuffers::Offset<skeleton>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<skeleton> Createskeleton(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<skeletonBone>>> bones = 0) {
  skeletonBuilder builder_(_fbb);
  builder_.add_bones(bones);
  return builder_.Finish();
}

struct animationBone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::Vector<float> *start_pt() const { return GetPointer<const flatbuffers::Vector<float> *>(6); }
  const flatbuffers::Vector<float> *end_pt() const { return GetPointer<const flatbuffers::Vector<float> *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* start_pt */) &&
           verifier.Verify(start_pt()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* end_pt */) &&
           verifier.Verify(end_pt()) &&
           verifier.EndTable();
  }
};

struct animationBoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_start_pt(flatbuffers::Offset<flatbuffers::Vector<float>> start_pt) { fbb_.AddOffset(6, start_pt); }
  void add_end_pt(flatbuffers::Offset<flatbuffers::Vector<float>> end_pt) { fbb_.AddOffset(8, end_pt); }
  animationBoneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationBoneBuilder &operator=(const animationBoneBuilder &);
  flatbuffers::Offset<animationBone> Finish() {
    auto o = flatbuffers::Offset<animationBone>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<animationBone> CreateanimationBone(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> start_pt = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> end_pt = 0) {
  animationBoneBuilder builder_(_fbb);
  builder_.add_end_pt(end_pt);
  builder_.add_start_pt(start_pt);
  builder_.add_name(name);
  return builder_.Finish();
}

struct animationBonesTimeSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationBone>> *bones() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationBone>> *>(4); }
  int32_t time() const { return GetField<int32_t>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* bones */) &&
           verifier.Verify(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           VerifyField<int32_t>(verifier, 6 /* time */) &&
           verifier.EndTable();
  }
};

struct animationBonesTimeSampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationBone>>> bones) { fbb_.AddOffset(4, bones); }
  void add_time(int32_t time) { fbb_.AddElement<int32_t>(6, time, 0); }
  animationBonesTimeSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationBonesTimeSampleBuilder &operator=(const animationBonesTimeSampleBuilder &);
  flatbuffers::Offset<animationBonesTimeSample> Finish() {
    auto o = flatbuffers::Offset<animationBonesTimeSample>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<animationBonesTimeSample> CreateanimationBonesTimeSample(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationBone>>> bones = 0,
   int32_t time = 0) {
  animationBonesTimeSampleBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_bones(bones);
  return builder_.Finish();
}

struct animationBonesList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationBonesTimeSample>> *timeSamples() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationBonesTimeSample>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* timeSamples */) &&
           verifier.Verify(timeSamples()) &&
           verifier.VerifyVectorOfTables(timeSamples()) &&
           verifier.EndTable();
  }
};

struct animationBonesListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeSamples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationBonesTimeSample>>> timeSamples) { fbb_.AddOffset(4, timeSamples); }
  animationBonesListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationBonesListBuilder &operator=(const animationBonesListBuilder &);
  flatbuffers::Offset<animationBonesList> Finish() {
    auto o = flatbuffers::Offset<animationBonesList>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<animationBonesList> CreateanimationBonesList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationBonesTimeSample>>> timeSamples = 0) {
  animationBonesListBuilder builder_(_fbb);
  builder_.add_timeSamples(timeSamples);
  return builder_.Finish();
}

struct animationMesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  uint8_t use_dq() const { return GetField<uint8_t>(6, 0); }
  uint8_t use_local_displacements() const { return GetField<uint8_t>(8, 0); }
  uint8_t use_post_displacements() const { return GetField<uint8_t>(10, 0); }
  const flatbuffers::Vector<float> *local_displacements() const { return GetPointer<const flatbuffers::Vector<float> *>(12); }
  const flatbuffers::Vector<float> *post_displacements() const { return GetPointer<const flatbuffers::Vector<float> *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, 6 /* use_dq */) &&
           VerifyField<uint8_t>(verifier, 8 /* use_local_displacements */) &&
           VerifyField<uint8_t>(verifier, 10 /* use_post_displacements */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* local_displacements */) &&
           verifier.Verify(local_displacements()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* post_displacements */) &&
           verifier.Verify(post_displacements()) &&
           verifier.EndTable();
  }
};

struct animationMeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_use_dq(uint8_t use_dq) { fbb_.AddElement<uint8_t>(6, use_dq, 0); }
  void add_use_local_displacements(uint8_t use_local_displacements) { fbb_.AddElement<uint8_t>(8, use_local_displacements, 0); }
  void add_use_post_displacements(uint8_t use_post_displacements) { fbb_.AddElement<uint8_t>(10, use_post_displacements, 0); }
  void add_local_displacements(flatbuffers::Offset<flatbuffers::Vector<float>> local_displacements) { fbb_.AddOffset(12, local_displacements); }
  void add_post_displacements(flatbuffers::Offset<flatbuffers::Vector<float>> post_displacements) { fbb_.AddOffset(14, post_displacements); }
  animationMeshBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationMeshBuilder &operator=(const animationMeshBuilder &);
  flatbuffers::Offset<animationMesh> Finish() {
    auto o = flatbuffers::Offset<animationMesh>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<animationMesh> CreateanimationMesh(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   uint8_t use_dq = 0,
   uint8_t use_local_displacements = 0,
   uint8_t use_post_displacements = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> local_displacements = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> post_displacements = 0) {
  animationMeshBuilder builder_(_fbb);
  builder_.add_post_displacements(post_displacements);
  builder_.add_local_displacements(local_displacements);
  builder_.add_name(name);
  builder_.add_use_post_displacements(use_post_displacements);
  builder_.add_use_local_displacements(use_local_displacements);
  builder_.add_use_dq(use_dq);
  return builder_.Finish();
}

struct animationMeshTimeSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationMesh>> *meshes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationMesh>> *>(4); }
  int32_t time() const { return GetField<int32_t>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* meshes */) &&
           verifier.Verify(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyField<int32_t>(verifier, 6 /* time */) &&
           verifier.EndTable();
  }
};

struct animationMeshTimeSampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMesh>>> meshes) { fbb_.AddOffset(4, meshes); }
  void add_time(int32_t time) { fbb_.AddElement<int32_t>(6, time, 0); }
  animationMeshTimeSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationMeshTimeSampleBuilder &operator=(const animationMeshTimeSampleBuilder &);
  flatbuffers::Offset<animationMeshTimeSample> Finish() {
    auto o = flatbuffers::Offset<animationMeshTimeSample>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<animationMeshTimeSample> CreateanimationMeshTimeSample(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMesh>>> meshes = 0,
   int32_t time = 0) {
  animationMeshTimeSampleBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_meshes(meshes);
  return builder_.Finish();
}

struct animationMeshList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationMeshTimeSample>> *timeSamples() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationMeshTimeSample>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* timeSamples */) &&
           verifier.Verify(timeSamples()) &&
           verifier.VerifyVectorOfTables(timeSamples()) &&
           verifier.EndTable();
  }
};

struct animationMeshListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeSamples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMeshTimeSample>>> timeSamples) { fbb_.AddOffset(4, timeSamples); }
  animationMeshListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationMeshListBuilder &operator=(const animationMeshListBuilder &);
  flatbuffers::Offset<animationMeshList> Finish() {
    auto o = flatbuffers::Offset<animationMeshList>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<animationMeshList> CreateanimationMeshList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMeshTimeSample>>> timeSamples = 0) {
  animationMeshListBuilder builder_(_fbb);
  builder_.add_timeSamples(timeSamples);
  return builder_.Finish();
}

struct animationUVSwap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::Vector<float> *local_offset() const { return GetPointer<const flatbuffers::Vector<float> *>(6); }
  const flatbuffers::Vector<float> *global_offset() const { return GetPointer<const flatbuffers::Vector<float> *>(8); }
  const flatbuffers::Vector<float> *scale() const { return GetPointer<const flatbuffers::Vector<float> *>(10); }
  uint8_t enabled() const { return GetField<uint8_t>(12, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* local_offset */) &&
           verifier.Verify(local_offset()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* global_offset */) &&
           verifier.Verify(global_offset()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* scale */) &&
           verifier.Verify(scale()) &&
           VerifyField<uint8_t>(verifier, 12 /* enabled */) &&
           verifier.EndTable();
  }
};

struct animationUVSwapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_local_offset(flatbuffers::Offset<flatbuffers::Vector<float>> local_offset) { fbb_.AddOffset(6, local_offset); }
  void add_global_offset(flatbuffers::Offset<flatbuffers::Vector<float>> global_offset) { fbb_.AddOffset(8, global_offset); }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) { fbb_.AddOffset(10, scale); }
  void add_enabled(uint8_t enabled) { fbb_.AddElement<uint8_t>(12, enabled, 0); }
  animationUVSwapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationUVSwapBuilder &operator=(const animationUVSwapBuilder &);
  flatbuffers::Offset<animationUVSwap> Finish() {
    auto o = flatbuffers::Offset<animationUVSwap>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<animationUVSwap> CreateanimationUVSwap(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> local_offset = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> global_offset = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
   uint8_t enabled = 0) {
  animationUVSwapBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_global_offset(global_offset);
  builder_.add_local_offset(local_offset);
  builder_.add_name(name);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct animationUVSwapTimeSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationUVSwap>> *uvSwaps() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationUVSwap>> *>(4); }
  int32_t time() const { return GetField<int32_t>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* uvSwaps */) &&
           verifier.Verify(uvSwaps()) &&
           verifier.VerifyVectorOfTables(uvSwaps()) &&
           VerifyField<int32_t>(verifier, 6 /* time */) &&
           verifier.EndTable();
  }
};

struct animationUVSwapTimeSampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uvSwaps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationUVSwap>>> uvSwaps) { fbb_.AddOffset(4, uvSwaps); }
  void add_time(int32_t time) { fbb_.AddElement<int32_t>(6, time, 0); }
  animationUVSwapTimeSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationUVSwapTimeSampleBuilder &operator=(const animationUVSwapTimeSampleBuilder &);
  flatbuffers::Offset<animationUVSwapTimeSample> Finish() {
    auto o = flatbuffers::Offset<animationUVSwapTimeSample>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<animationUVSwapTimeSample> CreateanimationUVSwapTimeSample(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationUVSwap>>> uvSwaps = 0,
   int32_t time = 0) {
  animationUVSwapTimeSampleBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_uvSwaps(uvSwaps);
  return builder_.Finish();
}

struct animationUVSwapList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationUVSwapTimeSample>> *timeSamples() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationUVSwapTimeSample>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* timeSamples */) &&
           verifier.Verify(timeSamples()) &&
           verifier.VerifyVectorOfTables(timeSamples()) &&
           verifier.EndTable();
  }
};

struct animationUVSwapListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeSamples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationUVSwapTimeSample>>> timeSamples) { fbb_.AddOffset(4, timeSamples); }
  animationUVSwapListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationUVSwapListBuilder &operator=(const animationUVSwapListBuilder &);
  flatbuffers::Offset<animationUVSwapList> Finish() {
    auto o = flatbuffers::Offset<animationUVSwapList>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<animationUVSwapList> CreateanimationUVSwapList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationUVSwapTimeSample>>> timeSamples = 0) {
  animationUVSwapListBuilder builder_(_fbb);
  builder_.add_timeSamples(timeSamples);
  return builder_.Finish();
}

struct animationMeshOpacity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  float opacity() const { return GetField<float>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<float>(verifier, 6 /* opacity */) &&
           verifier.EndTable();
  }
};

struct animationMeshOpacityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_opacity(float opacity) { fbb_.AddElement<float>(6, opacity, 0); }
  animationMeshOpacityBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationMeshOpacityBuilder &operator=(const animationMeshOpacityBuilder &);
  flatbuffers::Offset<animationMeshOpacity> Finish() {
    auto o = flatbuffers::Offset<animationMeshOpacity>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<animationMeshOpacity> CreateanimationMeshOpacity(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   float opacity = 0) {
  animationMeshOpacityBuilder builder_(_fbb);
  builder_.add_opacity(opacity);
  builder_.add_name(name);
  return builder_.Finish();
}

struct animationMeshOpacityTimeSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacity>> *meshOpacities() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacity>> *>(4); }
  int32_t time() const { return GetField<int32_t>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* meshOpacities */) &&
           verifier.Verify(meshOpacities()) &&
           verifier.VerifyVectorOfTables(meshOpacities()) &&
           VerifyField<int32_t>(verifier, 6 /* time */) &&
           verifier.EndTable();
  }
};

struct animationMeshOpacityTimeSampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshOpacities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacity>>> meshOpacities) { fbb_.AddOffset(4, meshOpacities); }
  void add_time(int32_t time) { fbb_.AddElement<int32_t>(6, time, 0); }
  animationMeshOpacityTimeSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationMeshOpacityTimeSampleBuilder &operator=(const animationMeshOpacityTimeSampleBuilder &);
  flatbuffers::Offset<animationMeshOpacityTimeSample> Finish() {
    auto o = flatbuffers::Offset<animationMeshOpacityTimeSample>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<animationMeshOpacityTimeSample> CreateanimationMeshOpacityTimeSample(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacity>>> meshOpacities = 0,
   int32_t time = 0) {
  animationMeshOpacityTimeSampleBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_meshOpacities(meshOpacities);
  return builder_.Finish();
}

struct animationMeshOpacityList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacityTimeSample>> *timeSamples() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacityTimeSample>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* timeSamples */) &&
           verifier.Verify(timeSamples()) &&
           verifier.VerifyVectorOfTables(timeSamples()) &&
           verifier.EndTable();
  }
};

struct animationMeshOpacityListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeSamples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacityTimeSample>>> timeSamples) { fbb_.AddOffset(4, timeSamples); }
  animationMeshOpacityListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationMeshOpacityListBuilder &operator=(const animationMeshOpacityListBuilder &);
  flatbuffers::Offset<animationMeshOpacityList> Finish() {
    auto o = flatbuffers::Offset<animationMeshOpacityList>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<animationMeshOpacityList> CreateanimationMeshOpacityList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationMeshOpacityTimeSample>>> timeSamples = 0) {
  animationMeshOpacityListBuilder builder_(_fbb);
  builder_.add_timeSamples(timeSamples);
  return builder_.Finish();
}

struct animationClip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const animationBonesList *bones() const { return GetPointer<const animationBonesList *>(6); }
  const animationMeshList *meshes() const { return GetPointer<const animationMeshList *>(8); }
  const animationUVSwapList *uvSwaps() const { return GetPointer<const animationUVSwapList *>(10); }
  const animationMeshOpacityList *meshOpacities() const { return GetPointer<const animationMeshOpacityList *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* bones */) &&
           verifier.VerifyTable(bones()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* meshes */) &&
           verifier.VerifyTable(meshes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* uvSwaps */) &&
           verifier.VerifyTable(uvSwaps()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* meshOpacities */) &&
           verifier.VerifyTable(meshOpacities()) &&
           verifier.EndTable();
  }
};

struct animationClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_bones(flatbuffers::Offset<animationBonesList> bones) { fbb_.AddOffset(6, bones); }
  void add_meshes(flatbuffers::Offset<animationMeshList> meshes) { fbb_.AddOffset(8, meshes); }
  void add_uvSwaps(flatbuffers::Offset<animationUVSwapList> uvSwaps) { fbb_.AddOffset(10, uvSwaps); }
  void add_meshOpacities(flatbuffers::Offset<animationMeshOpacityList> meshOpacities) { fbb_.AddOffset(12, meshOpacities); }
  animationClipBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationClipBuilder &operator=(const animationClipBuilder &);
  flatbuffers::Offset<animationClip> Finish() {
    auto o = flatbuffers::Offset<animationClip>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<animationClip> CreateanimationClip(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<animationBonesList> bones = 0,
   flatbuffers::Offset<animationMeshList> meshes = 0,
   flatbuffers::Offset<animationUVSwapList> uvSwaps = 0,
   flatbuffers::Offset<animationMeshOpacityList> meshOpacities = 0) {
  animationClipBuilder builder_(_fbb);
  builder_.add_meshOpacities(meshOpacities);
  builder_.add_uvSwaps(uvSwaps);
  builder_.add_meshes(meshes);
  builder_.add_bones(bones);
  builder_.add_name(name);
  return builder_.Finish();
}

struct animation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<animationClip>> *clips() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<animationClip>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* clips */) &&
           verifier.Verify(clips()) &&
           verifier.VerifyVectorOfTables(clips()) &&
           verifier.EndTable();
  }
};

struct animationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationClip>>> clips) { fbb_.AddOffset(4, clips); }
  animationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  animationBuilder &operator=(const animationBuilder &);
  flatbuffers::Offset<animation> Finish() {
    auto o = flatbuffers::Offset<animation>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<animation> Createanimation(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<animationClip>>> clips = 0) {
  animationBuilder builder_(_fbb);
  builder_.add_clips(clips);
  return builder_.Finish();
}

struct rootData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const mesh *dataMesh() const { return GetPointer<const mesh *>(4); }
  const skeleton *dataSkeleton() const { return GetPointer<const skeleton *>(6); }
  const animation *dataAnimation() const { return GetPointer<const animation *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* dataMesh */) &&
           verifier.VerifyTable(dataMesh()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* dataSkeleton */) &&
           verifier.VerifyTable(dataSkeleton()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* dataAnimation */) &&
           verifier.VerifyTable(dataAnimation()) &&
           verifier.EndTable();
  }
};

struct rootDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataMesh(flatbuffers::Offset<mesh> dataMesh) { fbb_.AddOffset(4, dataMesh); }
  void add_dataSkeleton(flatbuffers::Offset<skeleton> dataSkeleton) { fbb_.AddOffset(6, dataSkeleton); }
  void add_dataAnimation(flatbuffers::Offset<animation> dataAnimation) { fbb_.AddOffset(8, dataAnimation); }
  rootDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  rootDataBuilder &operator=(const rootDataBuilder &);
  flatbuffers::Offset<rootData> Finish() {
    auto o = flatbuffers::Offset<rootData>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<rootData> CreaterootData(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<mesh> dataMesh = 0,
   flatbuffers::Offset<skeleton> dataSkeleton = 0,
   flatbuffers::Offset<animation> dataAnimation = 0) {
  rootDataBuilder builder_(_fbb);
  builder_.add_dataAnimation(dataAnimation);
  builder_.add_dataSkeleton(dataSkeleton);
  builder_.add_dataMesh(dataMesh);
  return builder_.Finish();
}

inline const CreatureFlatData::rootData *GetrootData(const void *buf) { return flatbuffers::GetRoot<CreatureFlatData::rootData>(buf); }

inline bool VerifyrootDataBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<CreatureFlatData::rootData>(); }

inline void FinishrootDataBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<CreatureFlatData::rootData> root) { fbb.Finish(root); }

}  // namespace CreatureFlatData

#endif  // FLATBUFFERS_GENERATED_CREATUREFLATDATA_CREATUREFLATDATA_H_
